package robot.mapping;

import java.awt.Rectangle;
import java.util.ArrayList;

import lejos.nxt.LCD;
import robot.bluetooth.PlayerRole;
import robot.navigation.Odometer;

/**
 * Contains information about obstacles on the observed playing field. Contains static getters and setters as only one instance
 * of this class will exist.
 * 
 * @author Michael
 * @author Andreas
 * @version 2.0.0
 * @since 2013-11-09
 */
public class Map2 {	
	
	// Waypoints now used for getting home again
	private static double wpX = 30, wpY = 30;
	private static ArrayList<Double> waypointXs = new ArrayList<Double>();
	private static ArrayList<Double> waypointYs = new ArrayList<Double>();
	private static boolean newWaypoint = false;
	
	// Points to avoid
	
	private static ArrayList<Double> points = new ArrayList<Double>();
	
	// Contains the bounds of the object and whether or not it has been investigated
	// private static Hashtable<Ellipse2D.Double, Boolean> objects = new Hashtable<Ellipse2D.Double, Boolean>();

	private static int[] endPoints;
	private static int[] avoidPoints;
	private Rectangle avoidZone = new Rectangle();
	
	private static Object lock = new Object();
	/**
	 * Creates the map instance with the constructor of the robot mode 0-stacker 1-garbager
	 * @param mode
	 */
	public Map2(PlayerRole role, int[] redZone, int[] greenZone){
		endPoints = greenZone;
		avoidPoints = redZone;
		
		avoidZone.setSize(avoidPoints[2] - avoidPoints[0] ,avoidPoints[3] - avoidPoints[1]);
		avoidZone.setLocation(avoidPoints[0], avoidPoints[1]);
	}
	
	// Setters
	
	}

	/**
	 * Tells the map that a waypoint has been reached
	 */
	public static void waypointReached(){
		waypointXs.remove(0);
		waypointYs.remove(0);
		
		if(waypointXs.size() == 0){ // End of waypoint list i.e block/endpoint has been reached
			LCD.drawString("end of list", 0, 4);
			newWaypoint = false;
		}
		else{
			wpX = waypointXs.get(0);
			wpY = waypointYs.get(0);
		}
	}
	
	/**
	 * Adds a new set of coordinates following a scan that updates 
	 * @param newCoords - New set of coordinates to add to the map
	 */
	public static void addBlock(double[] xValues, double[] yValues){
		Block newBlock = new Block(xValues, yValues);
		double[] center = newBlock.getBlockCenter();
		
		for(int i=0; i < blocks.size(); i++){
			if(blocks.get(i).containsPoint(center[0], center[1])){
				blocks.get(i).mergeBlock(newBlock);
				return;
			}
		}
		blocks.add(new Block(xValues, yValues));
	}
	
	// Getters
	public static boolean checkPoint(double x, double y){
		for(int i=0; i<points.size(); i++){
			if(blocks.get(i).containsPoint(x, y))
				return true;
		}
		return false;
	}
	/**
	 * Checks if a new waypoint is available for the navigator to navigate to.
	 * @return boolean: newWaypoint
	 */
	public static boolean hasNewWaypoint(){
		synchronized(lock){
			return newWaypoint;
		}
	}
	
	/**
	 * Updates the waypoint array with the coordinates of the current waypoint to be traveled to.
	 * If the waypoint are new, set newWaypoints to false.
	 * @param wp - size 2 array for the x and y values of the waypoint
	 */
	public static void getWaypoint(double[] wp){
		synchronized(lock){
			wp[0] = wpX;
			wp[1] = wpY;
		}
	}

	public static double[] getEndCenter(){
		return new double[]{(endPoints[2] + endPoints[0])/  2, (endPoints[3] + endPoints[1]) / 2};
	}
	public static int getBlockCount(){
		return blocks.size();
	}
	public static int getWaypointCount(){
		return waypointXs.size();
	}
}
