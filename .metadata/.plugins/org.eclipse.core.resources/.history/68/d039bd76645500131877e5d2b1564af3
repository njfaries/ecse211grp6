package robot.mapping;

import lejos.nxt.LCD;
import robot.navigation.Navigation2;
import robot.navigation.Odometer;
import robot.sensors.USGather;

public class Scan2 {
	private static final double DISTANCE_THRESHOLD = 6;
	private Navigation2 nav;
	private USGather us;
	
	public Scan2(Navigation2 nav, USGather us){
		this.nav = nav;
		this.us = us;
	}
	/**
	 * Finds and returns the cetner value of the first block detected
	 * @param nav - The Navigation class being used
	 * @param us - The USGather class being used
	 */
	public double[] findBlock(double scanAngle){
		LCD.clear();
		LCD.drawString("scanning", 0, 5);
		
		double[] leftEdge = null;	
		double[] rightEdge = null;
		boolean blockFound = false;
		double edgeDist = -1;
		double currAngle = 0;
		
		// Creates empty array lists that data is added to
		double[] pos = new double[3];
		Odometer.getPosition(pos);
		
		// Performs a clockwise scan at an angle set by the input parameters
		nav.turnTo(pos[2] + scanAngle, 1);
		// Turn the scan amount to find a block
		int confidence = 0;
		
		currAngle = us.getFilteredData();
		if(currAngle < 60 && currAngle > 0)
			confidence = 3;
		while(!nav.isDone()){
			if(currAngle < 60 && currAngle > 0 && confidence >= 3){
				Odometer.getPosition(pos);
				blockFound = true;
				edgeDist = us.getFilteredData();
				currAngle = pos[2];
				leftEdge = new double[]{edgeDist, currAngle};
				break;
			}
			else if(us.getFilteredData() < 60)
				confidence++;
		}
		nav.stop();
		
		// If the search completed and did not pick up anything, return null
		// Otherwise, continue
		if(!blockFound)
			return null;
		
		// Turn clockwise to find the right falling edge
		nav.rotate(0);
		try { Thread.sleep(500); } catch (InterruptedException e) {}
		
		Odometer.getPosition(pos);
		double dist = us.getFilteredData();
		double angle = pos[2];
		// Keep turning clockwise until the right falling edge is detected
		while(dist < edgeDist + DISTANCE_THRESHOLD && dist > edgeDist - DISTANCE_THRESHOLD){
			Odometer.getPosition(pos);
			dist = us.getFilteredData();
			angle = pos[2];
			
			LCD.drawString(edgeDist + " " + dist + "              ", 0, 3);
			
			rightEdge = new double[]{edgeDist, angle};	
			try { Thread.sleep(50); } catch (InterruptedException e) {}
		}
		nav.stop();
		
		// Reverse to find the left falling edge
		nav.rotate(1);
		// Sleep to make sure the right corner isn't picked up a second time
		try { Thread.sleep(500); } catch (InterruptedException e) {}
		
		Odometer.getPosition(pos);
		dist = us.getFilteredData();
		angle = pos[2];
		// Keep turning Counter Clockwise to find the left falling edge
		while(dist < edgeDist + DISTANCE_THRESHOLD && dist > edgeDist - DISTANCE_THRESHOLD){
			Odometer.getPosition(pos);
			dist = us.getFilteredData();
			angle = pos[2];
			
			leftEdge = new double[]{edgeDist, angle};
			try { Thread.sleep(50); } catch (InterruptedException e) {}
		}
		nav.stop();
		
		// Calculate the center of the block based on the rising/falling edges
		return new double[]{(leftEdge[0] + rightEdge[0]) / 2, findAverageTheta(leftEdge[1], rightEdge[1])};
	}
	private double findAverageTheta(double t1, double t2){
		LCD.drawString((int)t1 + " " + (int)t2, 0, 4);
		if(t1 > 270 && t2 < 90)
			t1 -= 360;
		else if(t1 < 90 && t2 > 270)
			t2 -= 360;
		
		return (t1 + t2) / 2;
	}
}
